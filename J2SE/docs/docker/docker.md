### docker概述
之前听到的 `扩容` `缩容` 和docker有关？


### docker为什么出现，用于解决什么痛点
1. `场景`：开发完成后 打成jar包发给运维，开发：jar在环境a运行，运维：jar在环境b运行
   环境a b的各种软件版本mysql redis jdk等相差甚远
2. `解决方案`：开发环境开发好后，迁移到预发环境很麻烦，现在使用docker  
   自己本地开发的分布式系统，程序以及程序运行依赖的各种软件jdk mysql redis mq、配置文件等(环境)，
   把`环境`整个打包成一个包(docker镜像文件)，这个包到处运行
   实现了系统的平滑迁移
   就像：搬家很麻烦 般楼
   代码的迁移 不 整个运行环境的打包成镜像迁移 运行环境包括jdk 等各种软件
3. `docker好处`：
    1. 环境整体打包 避免了环境不一致(一次构建 到处运行)
    2. 更快速的应用交付、部署
    3. 便捷的升级、扩缩容
    4. 更简单的系统运维


### docker理念
一次镜像 处处运行，docker的角色和jvm有点像
1. Java运行在jvm上 屏蔽了Java与不同OS的差异 jar是到处运行
2. docker镜像运行在docker上，屏蔽了应用与不同OS的差异和环境迁移的复杂性 docker镜像也是到处运行
   实现了环境一致
3. centos7(OS)镜像文件 运行在vmware中，屏蔽了与原生OS的排斥性

设计思想都是一样的。

docker的主要目标：构建、装载、运行任何应用在任何地方
docker是一个容器虚拟化技术


### 相关术语
1. `docker镜像`
2. `docker容器`
3. `docker实例`
4. `docker hub`


### 容器&虚拟机
1. `传统虚拟机技术`：传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统
   (虚拟机里的OS)
2. `容器虚拟化技术`：容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，
   也没有进行硬件虚拟，
   每个容器之间相互隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源
   (容器里的应用进程)，
   比传统虚拟机速度快，docker镜像大小远小于vmware上所运行的OS镜像


### devops
devops：开发兼运维，开发运维一体化，技术中台


### docker官网&docker仓库
1. [docker官网](http://www.docker.com)
2. [Docker Hub官网](https://hub.docker.com)


### docker三要素
1. `镜像`：一个静态只读的镜像文件可以创建很多容器实例
2. `容器`：docker上面运行着很多`docker容器实例`
3. `docker仓库`：存放docker镜像的地方


### docker工作原理 c/s结构
1. docker客户端 docker命令
2. docker服务端(docker软件即docker引擎) `镜像` `容器实例` `拉取docker仓库`


### 安装docker软件
docker软件必须部署在Linux上

### 为什么docker比虚拟机快
1. docker不需要硬件虚拟化 docker容器里的程序用的是真实物理机的硬件资源
2. vm中OS实例的创建很慢 需要加载一个完整OS 而新建docker容器 直接利用宿主机操作系统 所以快


### docker命令
1. `帮助启动类命令`：docker服务端的启动/关闭
2. `镜像命令`：docker镜像相关的命令
3. 看到16集了
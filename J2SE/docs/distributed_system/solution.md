### 分布式锁
`线程锁：`如synchronized关键字、可重入锁api等，是多线程并发访问共享资源引起线程安全问题的一种解决方案  
`jvm本地锁：`对于一个服务节点，多个请求，请求共享资源(数据库的数据或内存数据) 可以使用synchronized关键字，或者可重入锁api  
**jvm本地锁3种失效场景**
1. service不是单例
2. 有事务。一个请求的开启的事务还没提交 另一个请求获取锁成功
3. 集群部署。不会是单例了

分布式锁，应用于分布式系统，多进程并发访问共享资源引起数据错误问题的一种解决方案，分布式锁实现方式3种：Redis，MySQL，Zookeeper  
场景：数据库里有一个字段值为10，对该字段操作，对于分布式系统，会有集群，用户的请求打到不同的进程  
这时，如果依然使用synchronized关键字显然不能再保护共享资源，这时就需要用到分布式锁，一个进程修改数据时  
其他进程不能修改这个数据，分布式锁就是解决这个问题的  

**分布式锁实现方案1(基于mysql)**  
基于mysql悲观锁：类似多线程并发的同步关键字，多个客户端请求同时访问不同进程，多个进程并发访问数据库，对于修改的记录(共享资源)，修改前加排他锁，类似同步锁，进程1获取到了锁执行sql，(其实本质就是mysql多个连接的并发)  
进程2获取不到锁则作出响应  
mysql innodb存储引擎，select for update，查询结果的数据被锁定(启用了排他锁 获取到了锁)，必须当前事务提交之后释放锁，这时其他阻塞的连接才能执行  
基于mysql乐观锁：乐观并发控制，不使用锁，使用版本号的概念，每次数据更新会伴随一个版本号。有点像cas，volatile  
**分布式锁实现方案2(基于redis)**  
setnx命令，获取到锁，执行。获取不到锁，阻塞/返回/重试... 思考：lock和trylock的区别  
redis集群会有一种情况导致分布式锁失效：  
场景：缓存集群是主从服务，主set key之后，从复制数据，会有io操作，耗时，一个连接获取到锁之后主挂了，从变成主但是还没来得及主从复制，另一个连接在主set key    
成功竟然获取到锁了，导致分布式锁失效。  
针对以上分布式锁失效场景，需要红锁redlock算法，redis特有  
[同步锁不足与分布式锁使用](https://www.cnblogs.com/skychmz/p/11498782.html)  
[分布式系统各节点状态同步](https://juejin.im/post/5c974072f265da60d428fadd)  
### 分布式事务
事务，原子性，要么全部成功，要么全部失败，分布式事务的这些操作位于不同的服务(进程)中  
微服务a db操作，微服务b db操作，某业务场景这两个db操作组成了一个分布式事务  

**分布式事务要遵循CAP理论**  
- C：consistency 一致性
- A：availability 可用性
- P：分区容忍性 partition tolerance

**但，CAP不能同时满足**
- CP：zookeeper 满足一致性、分区容忍性。刚性事务需要满足CP，对数据要求强一致性
- AP：eureka(Spring cloud组件)满足可用性、分区容忍性。柔性事务需要满足AP，不同节点的数据暂时不一致，但最终是一致的。base理论：满足可用性和分区容错性的同时，满足弱一致性(最终一致性，不立刻一致，过一段时间再一致)
- CA：不可采用，不满足分区容忍性就违反了分布式架构的意义。


分布式事务当中大部分都用到AP+base理论  
针对以上理论，衍生出了分布式事务的一些解决思想，如：XA，2PC，TCC等  
针对这些解决思想有衍生出了一些分布式事务框架，如：阿里巴巴开源的seata，LCN，这两种框架都可以解决分布式事务  
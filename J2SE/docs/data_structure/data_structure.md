### 数据结构
- `线性数据结构：` `队列` `栈` `一维数组` `Java List` `Java Set`
- `非线性数据结构：` `树` `图` `堆`

### 算法概述
算法都是时间换空间，空间换时间

### b+树
[mysqlB+树索引原理](https://blog.csdn.net/ifollowrivers/article/details/73614549)  
为了提高查找效率，采用了树这种逻辑结构  
科学家先后发明了二叉查找树、二叉排序树、平衡二叉树(AVLTree)、平衡多路查找树(B-树)、B+树  
B+树由这些数据结构演化而来，是目前最高效的查找数据结构。
B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中最频繁的一种索引  
B+树中的B代表平衡，而不是二叉(binary)，而B+树也是从最早的二叉平衡树演化而来的  
因此mysql b+树索引是一个数据结构。  

**B+树的优点**  
1. B+树是多叉树不是二叉树，且每个节点可以包含更多的节点(为了降低树的高度 另外一个是将数据范围变为多个区间，区间越多，数据检索越快)
2. 叶子节点两两相连，为顺序查询提供了帮助
3. 非叶子节点存储key，叶子节点存储key和数据
4. 每个节点不再只是存储一个key了，可以存储多个key

### 二叉查找树(二叉搜索树)
二叉查找树的查找、插入、删除最坏情况下时间复杂度都是O(n)
二叉查找树中序遍历有序！中序遍历是左->中->右  
但是二叉查找树可以任意构造，因为只要满足中序序列有序，它就是二叉查找树  
但是奇形怪状的二叉查找树查找效率不行，所以加了一些约束：平衡二叉树诞生了！  
所以从根节点查找数据 时间复杂度是树的高度

### 平衡二叉树(二叉搜索树的优化)
平衡二叉树也是二叉查找树，但是有个条件：平衡二叉树必须是任何一个节点的左右子树最大高度差为1，这才是平衡的。  
向AVL树中插入或删除一个节点，这可能会导致AVL失去平衡，AVL失去平衡有四种姿态：
1. LL：根节点的左孩子的左孩子还有非空节点
2. RR：根节点的右孩子的右孩子还有非空节点
3. LR：根节点的左孩子的右孩子还有非空节点
4. RL：根节点的右孩子的左孩子还有非空节点  

如果增删节点失去平衡，需要旋转使AVL恢复平衡，四种不平衡姿态对应四种不同旋转方式：
1. LL的旋转：
2. RR的旋转：
3. LR的旋转：
4. RL的旋转：

### 平衡多路查找树(B-树)
为磁盘等外存设备设计的一种平衡查找树  
**先了解一下磁盘相关知识**  
系统从磁盘读取数据到内存时是以磁盘块(block)为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么
InnoDB是MySQL中的一种存储引擎，存储引擎是数据库最核心的组件
InnoDB存储引擎中有页(Page)的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，MySQL查看页的大小：show variables like 'innodb_page_size'
一个磁盘块的存储空间 < 页的大小，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB
InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率
B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块
为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同  

**一棵m阶B-树的特性：**  
1. 每个节点最多有m个孩子，B树是多叉树
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子 m/2往大取整
3. 若根节点不是叶子节点，则至少有2个孩子
4. 所有叶子节点都在同一层，且不包含其它关键字信息
5. 先写到这，先缓缓...，下次接着写^-^


### 查找算法
查找算法的本质就是找分割点


### 线性数据结构排序算法
1. `内部排序` 完全在内存中完成的排序
2. `外部排序` 需要借助与磁盘io完成的排序

[8种排序算法](https://cloud.tencent.com/developer/article/1893903)

下面这些排序算法都是`内部排序`，其中`归并排序`也可以是`外部排序`

1. `插入排序`
    1. `直接插入排序`
    2. `折半插入排序`(是`直接插入排序`的一种改进)
    3. `希尔排序`
2. `选择排序`
    1. `简单选择排序`
    2. `堆排序`
3. `交换排序`
    1. `冒泡排序`
    2. `快速排序` 
4. `归并排序`
    1. `2-路归并排序`
5. `计数排序`

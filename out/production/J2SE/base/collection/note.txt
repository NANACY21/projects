[HashMap概述]


HashMap是一个散列桶（哈希桶，数组和链表），它存储的内容是键值对(key-value)映射
HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改
HashMap是非synchronized，所以HashMap很快
HashMap可以接受null键和值，而Hashtable则不能（原因就是equlas()方法需要对象，因为HashMap是后出的API经过处理才可以）


[HashMap工作原理]
HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。
当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。
这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。


[哈希冲突解决方案]
[1.开放地址法]
其中 m 为表的长度
对增量di有三种取法：
线性探测再散列   di = 1 , 2 , 3 , ... , m-1
平方探测再散列   di = 1 2 , -2 , 4 , -4 , 8 , -8 , ... , k的平方 ,  -k平方
随机探测再散列   di 是一组伪随机数列
[2.链地址法]
这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，
并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。
链地址法适用于经常进行插入和删除的情况。


[HashMap扩容原理]
默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，
和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，
来重新调整map的大小，并将原来的对象放入新的bucket数组中。
这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。
这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为<原下标+原容量>的位置


[什么是resize]
这是HashMap的扩容机制。
resize就是重新计算容量；
当我们不断的向HashMap对象里不停的添加元素时，HashMap对象内部的数组就会出现无法装载更多的元素，
这是对象就需要扩大数组的长度，以便能装入更多的元素；
当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组；
就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。


[什么时候需要resize]
当向容器添加元素的时候，会判断当前容器的元素个数，
如果大于等于阈值—即当前数组的长度乘以加载因子的值的时候，就要自动扩容。